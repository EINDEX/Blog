<!doctype html><html charset=utf-8 lang=en><head><link href=https://eindex.me/cn/feed.xml rel=alternate title=RSS type=application/rss+xml><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><meta content=EINDEX itemprop=author name=author><title>Tree in Python • EINDEX's Blog</title><meta content="Tree in Python • EINDEX's Blog" property=og:title><meta charset=utf-8><link href="https://eindex.me/css/index.css?h=2c6d1a0fefd9faaa38a353bc4db952f5de4a1db6f254410fbacf4ad38c320a57" rel=stylesheet><style>@-moz-document url-prefix() {.lazy:-moz-loading {visibility:hidden;}}.ieOnly {display: none;}@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {.ieOnly {display: block;}}</style><link href=https://webmention.io/eindex.me/webmention rel=webmention><link href=https://webmention.io/eindex.me/xmlrpc rel=pingback><script src=https://cdn.jsdelivr.net/npm/iconify-icon@1.0.1/dist/iconify-icon.min.js></script><link href=/favicon-512.png rel=apple-touch-icon sizes=512x512><link href=/favicon-512.png rel=icon sizes=512x512 type=image/png><link href=/favicon-192.png rel=icon sizes=192x192 type=image/png><link href=/manifest.json rel=manifest><meta content=https://eindex.me/cn/posts/tree-in-python/ property=og:url><meta content="EINDEX's Blog" property=og:site_name><meta content=https://eindex.me/images/avatar.png property=og:image><meta content=summary name=twitter:card><meta content="Tree in Python" name=twitter:title><meta content=@eindex_li name=twitter:site><meta content=@eindex_li name=twitter:creator><meta content=https://eindex.me/images/avatar.png name=twitter:image><script type=application/ld+json>
{
  "@context": "https://schema.org/",
  "@type": "BlogPosting",
  "headline": "Tree in Python",
  "image": "https://eindex.me/images/avatar.png",
  
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://eindex.me/cn/posts/tree-in-python/"
  },
  
  "datePublished": "2018-04-08",
  
  
  "author": {
    "@type": "Person",
    "name": "EINDEX",
    "url": "https://eindex.me/about"
  },
  "publisher": {
    "@type": "Organization",
    "name": "EINDEX's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://eindex.me/images/avatar.png"
    }
  },
  "keywords": ["Python","algorithm"]
}
</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1265138627025369" async crossorigin=anonymous></script><body><div class=all><header><nav class=navbar><div class=avatar><a class=site-link href=https://eindex.me/cn/><img alt=Workflow class=avatar src=https://eindex.me/processed_images/e75389feba7c019600.png></a></div><div class=menus><a href=https://eindex.me/cn/gallery/>相册</a><a href=https://eindex.me/cn/archive/>归档</a></div><div class=switcher><a class="language switch" href=https://eindex.me/><iconify-icon icon=ri:english-input></iconify-icon></a></div></nav></header><div class=content><main><article class=h-entry data-clarity-region=article><section class=header><section class=title-area><a class="series p-category" href=https://eindex.me/cn/series/algorithm/>Algorithm</a><h1 class="title p-name"><a class=u-url href=https://eindex.me/cn/posts/tree-in-python/>Tree in Python</a></h1></section><section class=meta-area><p style="display: none;" class=p-summary>&LTp>树是计算机科学中常用的数据结构之一,常见的地方有，Java 的继承树等。 还有一些基于树的特殊数据结构，比如二叉树，B 树，等等。&LT/p> &LTp>本篇会讲述一些关于简单关于树的操作。&LT/p></p><span><iconify-icon icon=ant-design:calendar-outlined></iconify-icon> <time class=dt-published>2018-04-08</time></span><span><iconify-icon icon=bx:time-five></iconify-icon> 7 mins</span></section></section><div class="p-author h-card" style="display: none;"><img class="u-logo u-photo" src=https://eindex.me/images/avatar.png><a class="p-nickname p-name u-url" href=https://eindex.me>EINDEX</a><p class=p-note>My goal is make happy.</div><section class="main e-content"><p>树是计算机科学中常用的数据结构之一,常见的地方有，Java 的继承树等。 还有一些基于树的特殊数据结构，比如二叉树，B 树，等等。<p>本篇会讲述一些关于简单关于树的操作。</p><span id=continue-reading></span><h2 id=shu-de-ding-yi>树的定义</h2><blockquote><p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</blockquote><blockquote><ul><li>每个节点有零个或多个子节点<li>没有父节点的节点称为根节点<li>每一个非根节点有且只有一个父节点<li>除了根节点外，每个子节点可以分为多个不相交的子树</ul></blockquote><p>节选自 <a href=https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) rel=nofollow>树(数据结构)</a><h2 id=ding-yi-shu-ju-jie-gou>定义数据结构</h2><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>class </span><span style=text-decoration:underline;color:#a6e22e;>TreeNode</span><span>(</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e;>object</span><span>):
</span><span>    </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>    一个树节点
</span><span style=color:#75715e;>    """
</span><span>
</span><span>    </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#66d9ef;>__init__</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>, </span><span style=font-style:italic;color:#fd971f;>value</span><span>, </span><span style=font-style:italic;color:#fd971f;>children</span><span>: </span><span style=font-style:italic;color:#66d9ef;>list </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>None</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>
</span><span style=color:#75715e;>        :param value: 节点的值
</span><span style=color:#75715e;>        :param children: 节点的子节点，一个 TreeNode 的列表
</span><span style=color:#75715e;>        """
</span><span>
</span><span>        self.value </span><span style=color:#f92672;>= </span><span>value
</span><span>
</span><span>        </span><span style=color:#f92672;>if not </span><span>children:
</span><span>            self.children </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>elif not </span><span>self.value:
</span><span>            self.children </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>else</span><span>:
</span><span>            self.children </span><span style=color:#f92672;>= </span><span>children
</span><span>
</span><span style=font-style:italic;color:#f92672;>class </span><span style=text-decoration:underline;color:#a6e22e;>Tree</span><span>(</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e;>object</span><span>):
</span><span>    </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>    树：基本树的数据结构
</span><span style=color:#75715e;>    """
</span><span>
</span><span>    </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#66d9ef;>__init__</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>, </span><span style=font-style:italic;color:#fd971f;>root</span><span>: TreeNode </span><span style=color:#f92672;>or </span><span style=color:#ae81ff;>None</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        传入根节点
</span><span style=color:#75715e;>        :param root: 如果为 TreeNode 为根节点， 如果为 None 为空书
</span><span style=color:#75715e;>        """
</span><span>        </span><span style=color:#f92672;>if not </span><span>(root </span><span style=color:#f92672;>is </span><span style=color:#ae81ff;>None </span><span style=color:#f92672;>or </span><span style=color:#66d9ef;>isinstance</span><span>(root, TreeNode)):
</span><span>            </span><span style=color:#f92672;>raise </span><span style=font-style:italic;color:#66d9ef;>AttributeError</span><span>(</span><span style=color:#e6db74;>'illegal root'</span><span>)
</span><span>        self.root </span><span style=color:#f92672;>= </span><span>root
</span></code></pre><h2 id=qian-xu-bian-li>前序遍历</h2><p>先遍历根节点。在遍历孩子节点。 <img alt=前序遍历 src=https://eindex.me/cn/posts/tree-in-python/media/15231560956719/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.jpg><h3 id=xun-huan-ban>循环版</h3><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span>    </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>preorder_traversal_while</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        树的前序遍历
</span><span style=color:#75715e;>        :return: list of tree node value
</span><span style=color:#75715e;>        """
</span><span>        res </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>if not </span><span>self.root:
</span><span>            </span><span style=color:#f92672;>return </span><span>res
</span><span>        stack </span><span style=color:#f92672;>= </span><span>[self.root]
</span><span>
</span><span>        </span><span style=color:#f92672;>while </span><span style=color:#66d9ef;>len</span><span>(stack):
</span><span>            node </span><span style=color:#f92672;>= </span><span>stack.pop()
</span><span>            </span><span style=color:#f92672;>if not </span><span>node.value:
</span><span>                </span><span style=color:#f92672;>continue
</span><span>            </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>node.children[::</span><span style=color:#f92672;>-</span><span style=color:#ae81ff;>1</span><span>]:
</span><span>                stack.append(sub_node)
</span><span>            res.append(node.value)
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span>res
</span></code></pre><h3 id=di-gui-ban>递归版</h3><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>preorder_traversal_recursion</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        树的前序遍历
</span><span style=color:#75715e;>        :return: list of tree node value
</span><span style=color:#75715e;>        """
</span><span>        res </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>if not </span><span>self.root:
</span><span>            </span><span style=color:#f92672;>return </span><span>res
</span><span>
</span><span>        </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>_inner</span><span>(</span><span style=font-style:italic;color:#fd971f;>root</span><span>):
</span><span>            inner_res </span><span style=color:#f92672;>= </span><span>[]
</span><span>            </span><span style=color:#f92672;>if </span><span>root.value:
</span><span>                inner_res.append(root.value)
</span><span>                </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>root.children:
</span><span>                    inner_res </span><span style=color:#f92672;>+= </span><span>_inner(sub_node)
</span><span>            </span><span style=color:#f92672;>return </span><span>inner_res
</span><span>        </span><span style=color:#f92672;>return </span><span>_inner(self.root)
</span></code></pre><h2 id=hou-xu-bian-li>后序遍历</h2><p>先遍历孩子节点，最后遍历根节点。<p><img alt=后序遍历 src=https://eindex.me/cn/posts/tree-in-python/media/15231560956719/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg><h3 id=xun-huan-ban-1>循环版</h3><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>postorder_traversal_while</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        树的后序遍历
</span><span style=color:#75715e;>        :return: list of tree node value
</span><span style=color:#75715e;>        """
</span><span>        res </span><span style=color:#f92672;>= </span><span>[]
</span><span>
</span><span>        </span><span style=color:#f92672;>if not </span><span>self.root:
</span><span>            </span><span style=color:#f92672;>return </span><span>res
</span><span>
</span><span>        stack </span><span style=color:#f92672;>= </span><span>[self.root]
</span><span>
</span><span>        </span><span style=color:#f92672;>while </span><span style=color:#66d9ef;>len</span><span>(stack):
</span><span>            node </span><span style=color:#f92672;>= </span><span>stack.pop()
</span><span>            </span><span style=color:#f92672;>if not </span><span>node.value:
</span><span>                </span><span style=color:#f92672;>continue
</span><span>            </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>node.children:
</span><span>                stack.append(sub_node)
</span><span>            res.append(node.value)
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span>res[::</span><span style=color:#f92672;>-</span><span style=color:#ae81ff;>1</span><span>]
</span></code></pre><h3 id=di-gui-ban-1>递归版</h3><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span>   </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>postorder_traversal_recursion</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        树的后序遍历
</span><span style=color:#75715e;>        :return: list of tree node value
</span><span style=color:#75715e;>        """
</span><span>        res </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>if not </span><span>self.root:
</span><span>            </span><span style=color:#f92672;>return </span><span>res
</span><span>
</span><span>        </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>_inner</span><span>(</span><span style=font-style:italic;color:#fd971f;>root</span><span>):
</span><span>            inner_res </span><span style=color:#f92672;>= </span><span>[]
</span><span>            </span><span style=color:#f92672;>if </span><span>root.value:
</span><span>                </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>root.children:
</span><span>                    inner_res </span><span style=color:#f92672;>+= </span><span>_inner(sub_node)
</span><span>                inner_res.append(root.value)
</span><span>            </span><span style=color:#f92672;>return </span><span>inner_res
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span>_inner(self.root)
</span><span>
</span></code></pre><h2 id=ceng-ci-bian-li>层次遍历</h2><p>按层遍历节点。 <img alt=层序遍历 src=https://eindex.me/cn/posts/tree-in-python/media/15231560956719/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg><h3 id=xun-huan-ban-2>循环版</h3><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>layer_while</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=color:#75715e;>"""
</span><span style=color:#75715e;>        树的层序遍历
</span><span style=color:#75715e;>        :return: list of tree node value
</span><span style=color:#75715e;>        """
</span><span>        res </span><span style=color:#f92672;>= </span><span>[]
</span><span>        </span><span style=color:#f92672;>if not </span><span>self.root:
</span><span>            </span><span style=color:#f92672;>return </span><span>res
</span><span>
</span><span>        queue </span><span style=color:#f92672;>= </span><span>Queue()
</span><span>        queue.put(self.root)
</span><span>
</span><span>        </span><span style=color:#f92672;>while </span><span>queue.qsize():
</span><span>            node </span><span style=color:#f92672;>= </span><span>queue.get()
</span><span>            </span><span style=color:#f92672;>if not </span><span>node.value:
</span><span>                </span><span style=color:#f92672;>continue
</span><span>            res.append(node.value)
</span><span>            </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>node.children:
</span><span>                queue.put(sub_node)
</span><span>        </span><span style=color:#f92672;>return </span><span>res
</span></code></pre><h2 id=qiu-shu-de-shen-du>求树的深度</h2><p>计算树的最大深度。<pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span> </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>depth_recursion</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>
</span><span>        </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>_inner</span><span>(</span><span style=font-style:italic;color:#fd971f;>root</span><span>, </span><span style=font-style:italic;color:#fd971f;>depth</span><span style=color:#f92672;>=</span><span style=color:#ae81ff;>1</span><span>):
</span><span>            </span><span style=color:#f92672;>if not </span><span>root.children:
</span><span>                </span><span style=color:#f92672;>return </span><span>depth
</span><span>            </span><span style=color:#f92672;>return </span><span style=color:#66d9ef;>max</span><span>([_inner(sub_node, depth</span><span style=color:#f92672;>+</span><span style=color:#ae81ff;>1</span><span>) </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>root.children])
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span>_inner(self.root)
</span></code></pre><h2 id=qiu-shu-de-jie-dian-shu>求树的结点数</h2><p>计算树一共有多少节点。<pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span> </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>node_count</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>_inner</span><span>(</span><span style=font-style:italic;color:#fd971f;>root</span><span>):
</span><span>            </span><span style=color:#f92672;>if not </span><span>root.children:
</span><span>                </span><span style=color:#f92672;>return </span><span style=color:#ae81ff;>1
</span><span>            </span><span style=color:#f92672;>return </span><span style=color:#ae81ff;>1 </span><span style=color:#f92672;>+ </span><span style=color:#66d9ef;>sum</span><span>([_inner(sub_node) </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>root.children])
</span><span>        </span><span style=color:#f92672;>return </span><span>_inner(self.root)
</span></code></pre><h2 id=qiu-shu-de-xie-zi-shu>求树的叶子数</h2><p>计算书中有多少没有孩子的节点。<pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>leaf_count</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>):
</span><span>        </span><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>_inner</span><span>(</span><span style=font-style:italic;color:#fd971f;>root</span><span>):
</span><span>            </span><span style=color:#f92672;>if not </span><span>root.children:
</span><span>                </span><span style=color:#f92672;>return </span><span style=color:#ae81ff;>1
</span><span>            </span><span style=color:#f92672;>return </span><span style=color:#66d9ef;>sum</span><span>([_inner(sub_node) </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>root.children])
</span><span>        </span><span style=color:#f92672;>return </span><span>_inner(self.root)
</span></code></pre><h2 id=qiu-liang-ge-jie-dian-de-zui-di-gong-gong-zu-xian-jie-dian>求两个结点的最低公共祖先结点</h2><p>首先需要在树中找到两个结点。 保存找到两个节点的链表。 遍历两个链表的最长公共节点，就能找到最低的公共祖先节点。 <img alt=最低公共祖先节点 src=https://eindex.me/cn/posts/tree-in-python/media/15231560956719/%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9.jpg><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>lowest_ancestor_node</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>, </span><span style=font-style:italic;color:#fd971f;>node1</span><span>, </span><span style=font-style:italic;color:#fd971f;>node2</span><span>):
</span><span>        stack </span><span style=color:#f92672;>= </span><span>[self.root]
</span><span>        stack1 </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>None
</span><span>        stack2 </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>None
</span><span>
</span><span>        </span><span style=color:#f92672;>while </span><span style=color:#66d9ef;>len</span><span>(stack) </span><span style=color:#f92672;>and not </span><span>(stack1 </span><span style=color:#f92672;>and </span><span>stack2):
</span><span>            node </span><span style=color:#f92672;>= </span><span>stack.pop()
</span><span>
</span><span>            </span><span style=color:#f92672;>if </span><span>node </span><span style=color:#f92672;>is </span><span>node1:
</span><span>                stack1 </span><span style=color:#f92672;>= </span><span>stack[:]
</span><span>            </span><span style=color:#f92672;>if </span><span>node </span><span style=color:#f92672;>is </span><span>node2:
</span><span>                stack2 </span><span style=color:#f92672;>= </span><span>stack[:]
</span><span>            </span><span style=color:#f92672;>if not </span><span>node.value:
</span><span>                </span><span style=color:#f92672;>continue
</span><span>            </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>node.children:
</span><span>                stack.append(sub_node)
</span><span>
</span><span>        res </span><span style=color:#f92672;>= </span><span>self.root
</span><span>        </span><span style=color:#f92672;>for </span><span>i </span><span style=color:#f92672;>in </span><span style=color:#66d9ef;>range</span><span>(</span><span style=color:#66d9ef;>len</span><span>(stack1)):
</span><span>            </span><span style=color:#f92672;>if </span><span>stack1[i] </span><span style=color:#f92672;>== </span><span>stack2[i]:
</span><span>                res </span><span style=color:#f92672;>= </span><span>stack1[i]
</span><span>            </span><span style=color:#f92672;>else</span><span>:
</span><span>                </span><span style=color:#f92672;>return </span><span>res.value
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span>res.value
</span></code></pre><h2 id=qiu-ren-yi-liang-jie-dian-ju-chi>求任意两结点距离</h2><p>首先需要在树中找到两个结点。 保存找到两个节点的链表。 在判断剩余的长度 <img alt=任意两节点距离 src=https://eindex.me/cn/posts/tree-in-python/media/15231560956719/%E4%BB%BB%E6%84%8F%E4%B8%A4%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB.jpg><pre class=language-python data-lang=python style=background-color:#272822;color:#f8f8f2;><code class=language-python data-lang=python><span style=font-style:italic;color:#f92672;>def </span><span style=color:#a6e22e;>two_node_distence</span><span>(</span><span style=font-style:italic;color:#fd971f;>self</span><span>, </span><span style=font-style:italic;color:#fd971f;>node1</span><span>, </span><span style=font-style:italic;color:#fd971f;>node2</span><span>):
</span><span>        stack </span><span style=color:#f92672;>= </span><span>[self.root]
</span><span>        stack1 </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>None
</span><span>        stack2 </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>None
</span><span>
</span><span>        </span><span style=color:#f92672;>while </span><span style=color:#66d9ef;>len</span><span>(stack) </span><span style=color:#f92672;>and not </span><span>(stack1 </span><span style=color:#f92672;>and </span><span>stack2):
</span><span>            node </span><span style=color:#f92672;>= </span><span>stack.pop()
</span><span>
</span><span>            </span><span style=color:#f92672;>if </span><span>node </span><span style=color:#f92672;>is </span><span>node1:
</span><span>                stack1 </span><span style=color:#f92672;>= </span><span>stack[:]
</span><span>            </span><span style=color:#f92672;>if </span><span>node </span><span style=color:#f92672;>is </span><span>node2:
</span><span>                stack2 </span><span style=color:#f92672;>= </span><span>stack[:]
</span><span>            </span><span style=color:#f92672;>if not </span><span>node.value:
</span><span>                </span><span style=color:#f92672;>continue
</span><span>            </span><span style=color:#f92672;>for </span><span>sub_node </span><span style=color:#f92672;>in </span><span>node.children:
</span><span>                stack.append(sub_node)
</span><span>
</span><span>        res </span><span style=color:#f92672;>= </span><span>self.root
</span><span>        </span><span style=color:#f92672;>for </span><span>i </span><span style=color:#f92672;>in </span><span style=color:#66d9ef;>range</span><span>(</span><span style=color:#66d9ef;>len</span><span>(stack1)):
</span><span>            </span><span style=color:#f92672;>if </span><span>stack1[i] </span><span style=color:#f92672;>== </span><span>stack2[i]:
</span><span>                res </span><span style=color:#f92672;>= </span><span>stack1[i]
</span><span>            </span><span style=color:#f92672;>else</span><span>:
</span><span>                </span><span style=color:#f92672;>return </span><span style=color:#66d9ef;>len</span><span>(stack1) </span><span style=color:#f92672;>+ </span><span style=color:#66d9ef;>len</span><span>(stack2) </span><span style=color:#f92672;>- </span><span style=color:#ae81ff;>2</span><span style=color:#f92672;>*</span><span>i
</span><span>
</span><span>        </span><span style=color:#f92672;>return </span><span style=color:#66d9ef;>len</span><span>(stack1) </span><span style=color:#f92672;>+ </span><span style=color:#66d9ef;>len</span><span>(stack2) </span><span style=color:#f92672;>- </span><span style=color:#ae81ff;>2</span><span style=color:#f92672;>*</span><span>i
</span><span>
</span></code></pre><h2 id=zong-shu>综述</h2><p>以上就是和树有关联的简单代码。 以上代码也在 Github 上发布 <a href=https://github.com/EINDEX/Python-algorithm/blob/master/data_structure/tree/tree.py rel=nofollow>tree</a>， 如有差错，欢迎提交 Issue 或 PR。<h2 id=geng-xin>更新</h2><ul><li>修复图片的 Bug</ul></section><section class=post-footer><div class=tags><span class=tag><a href=https://eindex.me/cn/tags/python/>Python</a></span></div></section></article></main><aside></aside></div><footer class=footer><span class=webring> <a href=https://xn--sr8hvo.ws/%F0%9F%95%90%F0%9F%89%91%F0%9F%88%B6/previous>←</a> An IndieWeb Webring 🕸💍 <a href=https://xn--sr8hvo.ws/%F0%9F%95%90%F0%9F%89%91%F0%9F%88%B6/next>→</a> </span><link href=https://github.com/EINDEX rel=me></footer></div>